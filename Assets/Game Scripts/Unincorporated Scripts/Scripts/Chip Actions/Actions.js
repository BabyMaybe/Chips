#pragma strict//This file is intended to be an outline for subclassing//Common functions are outlined here to be overwritten in subclassesvar canMove : boolean =false;var currentBlock : String = "Floor";enum Facing {Up = 0, Right = 90, Down = 180, Left = 270};var currentDirection : Facing;var upKey : String = ",";var downKey : String = "o";var leftKey : String = "a";var rightKey : String = "e";//Tile Specific interactions//These get called through the OnTriggerEnter function of the triggered tilefunction Fire() {	//Enter code to deal with Fire here	Kill();}function Water() {	//Enter code to deal with Water here	Kill();}function Conveyer() {	//Enter code to deal with Conveyer Floors here}function Ice() {	//Enter code to deal with Ice here}function IceCorner() {	//Enter code to deal with Ice Corners here}function Monster() {	//Enter code to deal with Monsters here}//These functions are typically called internally and//manipulate the gameObject in some mannerfunction StopMove() {	//Stops ability to move	canMove = false;	}function StartMove() {	//Starts ability to move	canMove = true;	}function Move() {	//Moves object forward one block		if (canMove) {		transform.Translate(Vector3.forward * 2);	}	}function UpdateCurrentBlock() {	//Detects the name of the first block found up to one block beneath gameObject	var ray : Ray = new Ray (transform.position,transform.TransformDirection(Vector3.down));	var hit : RaycastHit;		if (Physics.Raycast(ray,hit,2)) {	    	currentBlock = hit.collider.name;        print(currentBlock);    }	}function UpdateRestrictions() {		switch (currentBlock) {				case "Ice":			canMove = false;			break;		case "Ice Corner":			canMove = false;			break;					case "Conveyer":		//need to update this to canMovePerpendicular somehow			canMove = false;			break;					case "Floor":			canMove = true;			break;					default:			canMove = true;			break;					}	}function UpdateDirection () {    //Turns keypress into rotation currentDirection    //Moves forward if clear ahead	if (Input.anyKeyDown) {    	if (Input.GetAxis("Vertical") > 0) {    		transform.eulerAngles.y = 0;    		currentDirection = Facing.Up;        }    	if (Input.GetAxis("Horizontal") > 0) {    	    transform.eulerAngles.y = 90;    		currentDirection = Facing.Right;        }        if (Input.GetAxis("Vertical") < 0) {    		transform.eulerAngles.y = 180;    		currentDirection = Facing.Down;        }    	if (Input.GetAxis("Horizontal") < 0) {    		transform.eulerAngles.y = 270;    		currentDirection = Facing.Left;    	}        	CheckAhead();        Move();   }}function CheckAhead() {	//Sends a ray one block in front of gameObject	//if object in the way is tagged as impassible Activate() sent to object and second ray sent	//if object still in way prevents movement in that currentDirection			var ray : Ray = new Ray (transform.position,transform.TransformDirection (Vector3.forward));	var hit : RaycastHit;		if (Physics.Raycast(ray,hit,2)) {					//either change the method for detecting immovable objects or further exand tagging system		//i dont like this solution right now...		if (hit.collider.tag == "Impassible") {										hit.transform.gameObject.SendMessage("Activate",SendMessageOptions.DontRequireReceiver);								if (Physics.Raycast(ray,hit,2)) {										StopMove();					}			}		}	StartMove();}function Kill() {	//Destroys current object		Destroy(gameObject);	}function Hide() {	//Draws object below floor - useful when sound needs to play on object destruction	//or object needs to complete some action before it is destroyed	transform.Translate(0,-100,0);	}